(self.webpackChunk_plone_volto=self.webpackChunk_plone_volto||[]).push([[7280],{"../../../node_modules/.pnpm/jotai@2.0.3_react@18.2.0/node_modules/jotai/esm/react.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{lZ:function(){return useAtom}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"),jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("../../../node_modules/.pnpm/jotai@2.0.3_react@18.2.0/node_modules/jotai/esm/vanilla.mjs");const StoreContext=(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0),useStore=options=>{const store=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);return(null==options?void 0:options.store)||store||(0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.K0)()},isPromise=x=>x instanceof Promise,use=react__WEBPACK_IMPORTED_MODULE_0__.use||(promise=>{if("pending"===promise.status)throw promise;if("fulfilled"===promise.status)return promise.value;throw"rejected"===promise.status?promise.reason:(promise.status="pending",promise.then((v=>{promise.status="fulfilled",promise.value=v}),(e=>{promise.status="rejected",promise.reason=e})),promise)});function useAtomValue(atom,options){const store=useStore(options),[[valueFromReducer,storeFromReducer,atomFromReducer],rerender]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev=>{const nextValue=store.get(atom);return Object.is(prev[0],nextValue)&&prev[1]===store&&prev[2]===atom?prev:[nextValue,store,atom]}),void 0,(()=>[store.get(atom),store,atom]));let value=valueFromReducer;storeFromReducer===store&&atomFromReducer===atom||(rerender(),value=store.get(atom));const delay=null==options?void 0:options.delay;return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{const unsub=store.sub(atom,(()=>{"number"!=typeof delay?rerender():setTimeout(rerender,delay)}));return rerender(),unsub}),[store,atom,delay]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value),isPromise(value)?use(value):value}function useSetAtom(atom,options){const store=useStore(options);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(((...args)=>{if(!("write"in atom))throw new Error("not writable atom");return store.set(atom,...args)}),[store,atom])}function useAtom(atom,options){return[useAtomValue(atom,options),useSetAtom(atom,options)]}},"../../../node_modules/.pnpm/jotai@2.0.3_react@18.2.0/node_modules/jotai/esm/vanilla.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{K0:function(){return getDefaultStore},Zf:function(){return atom}});let keyCount=0;function atom(read,write){const key="atom"+ ++keyCount,config={toString:()=>key};return"function"==typeof read?config.read=read:(config.init=read,config.read=get=>get(config),config.write=(get,set,arg)=>set(config,"function"==typeof arg?arg(get(config)):arg)),write&&(config.write=write),config}const hasInitialValue=atom=>"init"in atom,isActuallyWritableAtom=atom=>!!atom.write,cancelPromiseMap=new WeakMap,cancelPromise=(promise,next)=>{const cancel=cancelPromiseMap.get(promise);cancel&&(cancelPromiseMap.delete(promise),cancel(next))},resolvePromise=(promise,value)=>{promise.status="fulfilled",promise.value=value},rejectPromise=(promise,e)=>{promise.status="rejected",promise.reason=e},isEqualAtomValue=(a,b)=>"v"in a&&"v"in b&&Object.is(a.v,b.v),isEqualAtomError=(a,b)=>"e"in a&&"e"in b&&Object.is(a.e,b.e),hasPromiseAtomValue=a=>"v"in a&&a.v instanceof Promise,returnAtomValue=atomState=>{if("e"in atomState)throw atomState.e;return atomState.v},createStore=()=>{const atomStateMap=new WeakMap,mountedMap=new WeakMap,pendingMap=new Map;let stateListeners,storeListeners,mountedAtoms;stateListeners=new Set,storeListeners=new Set,mountedAtoms=new Set;const getAtomState=atom=>atomStateMap.get(atom),setAtomState=(atom,atomState)=>{Object.freeze(atomState);const prevAtomState=atomStateMap.get(atom);if(atomStateMap.set(atom,atomState),pendingMap.has(atom)||pendingMap.set(atom,prevAtomState),prevAtomState&&hasPromiseAtomValue(prevAtomState)){const next="v"in atomState?atomState.v instanceof Promise?atomState.v:Promise.resolve(atomState.v):Promise.reject(atomState.e);cancelPromise(prevAtomState.v,next)}},updateDependencies=(atom,nextAtomState,depSet)=>{const dependencies=new Map;let changed=!1;depSet.forEach((a=>{const aState=a===atom?nextAtomState:getAtomState(a);aState?(dependencies.set(a,aState),nextAtomState.d.get(a)!==aState&&(changed=!0)):console.warn("[Bug] atom state not found")})),(changed||nextAtomState.d.size!==dependencies.size)&&(nextAtomState.d=dependencies)},setAtomValue=(atom,value,depSet)=>{const prevAtomState=getAtomState(atom),nextAtomState={d:(null==prevAtomState?void 0:prevAtomState.d)||new Map,v:value};return depSet&&updateDependencies(atom,nextAtomState,depSet),prevAtomState&&isEqualAtomValue(prevAtomState,nextAtomState)&&prevAtomState.d===nextAtomState.d?prevAtomState:(setAtomState(atom,nextAtomState),nextAtomState)},readAtomState=atom=>{const atomState=getAtomState(atom);if(atomState&&(atomState.d.forEach(((_,a)=>{a===atom||mountedMap.has(a)||readAtomState(a)})),Array.from(atomState.d).every((([a,s])=>a===atom||getAtomState(a)===s))))return atomState;const depSet=new Set;let isSync=!0;const getter=a=>{if(depSet.add(a),a===atom){const aState2=getAtomState(a);if(aState2)return returnAtomValue(aState2);if(hasInitialValue(a))return a.init;throw new Error("no atom init")}const aState=readAtomState(a);return returnAtomValue(aState)};let controller,setSelf;const options={get signal(){return controller||(controller=new AbortController),controller.signal},get setSelf(){return isActuallyWritableAtom(atom)||console.warn("setSelf function cannot be used with read-only atom"),!setSelf&&isActuallyWritableAtom(atom)&&(setSelf=(...args)=>{if(isSync&&console.warn("setSelf function cannot be called in sync"),!isSync)return writeAtom(atom,...args)}),setSelf}};try{const value=atom.read(getter,options);if(value instanceof Promise){let continuePromise;const promise=new Promise(((resolve,reject)=>{let settled=!1;value.then((v=>{settled||(settled=!0,setAtomValue(atom,promise,depSet),resolvePromise(promise,v),resolve(v))}),(e=>{settled||(settled=!0,setAtomValue(atom,promise,depSet),rejectPromise(promise,e),reject(e))})),continuePromise=next=>{settled||(settled=!0,next.then((v=>resolvePromise(promise,v)),(e=>rejectPromise(promise,e))),resolve(next))}}));return promise.status="pending",((promise,cancel)=>{cancelPromiseMap.set(promise,cancel),promise.catch((()=>{})).finally((()=>cancelPromiseMap.delete(promise)))})(promise,(next=>{next&&continuePromise(next),null==controller||controller.abort()})),setAtomValue(atom,promise,depSet)}return setAtomValue(atom,value,depSet)}catch(error){return((atom,error,depSet)=>{const prevAtomState=getAtomState(atom),nextAtomState={d:(null==prevAtomState?void 0:prevAtomState.d)||new Map,e:error};return depSet&&updateDependencies(atom,nextAtomState,depSet),prevAtomState&&isEqualAtomError(prevAtomState,nextAtomState)&&prevAtomState.d===nextAtomState.d?prevAtomState:(setAtomState(atom,nextAtomState),nextAtomState)})(atom,error,depSet)}finally{isSync=!1}},readAtom=atom=>returnAtomValue(readAtomState(atom)),canUnmountAtom=(atom,mounted)=>!mounted.l.size&&(!mounted.t.size||1===mounted.t.size&&mounted.t.has(atom)),recomputeDependents=atom=>{const mounted=mountedMap.get(atom);null==mounted||mounted.t.forEach((dependent=>{if(dependent!==atom){const prevAtomState=getAtomState(dependent),nextAtomState=readAtomState(dependent);prevAtomState&&isEqualAtomValue(prevAtomState,nextAtomState)||recomputeDependents(dependent)}}))},writeAtomState=(atom,...args)=>{let isSync=!0;const result=atom.write((a=>returnAtomValue(readAtomState(a))),((a,...args2)=>{let r;if(a===atom){if(!hasInitialValue(a))throw new Error("atom not writable");const prevAtomState=getAtomState(a),nextAtomState=setAtomValue(a,args2[0]);prevAtomState&&isEqualAtomValue(prevAtomState,nextAtomState)||recomputeDependents(a)}else r=writeAtomState(a,...args2);return isSync||flushPending(),r}),...args);return isSync=!1,result},writeAtom=(atom,...args)=>{const result=writeAtomState(atom,...args);return flushPending(),result},mountAtom=(atom,initialDependent)=>{const mounted={t:new Set(initialDependent&&[initialDependent]),l:new Set};if(mountedMap.set(atom,mounted),mountedAtoms.add(atom),readAtomState(atom).d.forEach(((_,a)=>{const aMounted=mountedMap.get(a);aMounted?aMounted.t.add(atom):a!==atom&&mountAtom(a,atom)})),readAtomState(atom),isActuallyWritableAtom(atom)&&atom.onMount){const onUnmount=atom.onMount(((...args)=>writeAtom(atom,...args)));onUnmount&&(mounted.u=onUnmount)}return mounted},unmountAtom=atom=>{var _a;const onUnmount=null==(_a=mountedMap.get(atom))?void 0:_a.u;onUnmount&&onUnmount(),mountedMap.delete(atom),mountedAtoms.delete(atom);const atomState=getAtomState(atom);atomState?(hasPromiseAtomValue(atomState)&&cancelPromise(atomState.v),atomState.d.forEach(((_,a)=>{if(a!==atom){const mounted=mountedMap.get(a);mounted&&(mounted.t.delete(atom),canUnmountAtom(a,mounted)&&unmountAtom(a))}}))):console.warn("[Bug] could not find atom state to unmount",atom)},mountDependencies=(atom,atomState,prevDependencies)=>{const depSet=new Set(atomState.d.keys());null==prevDependencies||prevDependencies.forEach(((_,a)=>{if(depSet.has(a))return void depSet.delete(a);const mounted=mountedMap.get(a);mounted&&(mounted.t.delete(atom),canUnmountAtom(a,mounted)&&unmountAtom(a))})),depSet.forEach((a=>{const mounted=mountedMap.get(a);mounted?mounted.t.add(atom):mountedMap.has(atom)&&mountAtom(a,atom)}))},flushPending=()=>{for(;pendingMap.size;){const pending=Array.from(pendingMap);pendingMap.clear(),pending.forEach((([atom,prevAtomState])=>{const atomState=getAtomState(atom);if(atomState){atomState.d!==(null==prevAtomState?void 0:prevAtomState.d)&&mountDependencies(atom,atomState,null==prevAtomState?void 0:prevAtomState.d);const mounted=mountedMap.get(atom);!mounted||prevAtomState&&!hasPromiseAtomValue(prevAtomState)&&(isEqualAtomValue(prevAtomState,atomState)||isEqualAtomError(prevAtomState,atomState))||mounted.l.forEach((listener=>listener()))}else console.warn("[Bug] no atom state to flush")}))}stateListeners.forEach((l=>l())),storeListeners.forEach((l=>l("state")))},subscribeAtom=(atom,listener)=>{const mounted=(atom=>{let mounted=mountedMap.get(atom);return mounted||(mounted=mountAtom(atom)),mounted})(atom);flushPending();const listeners=mounted.l;return listeners.add(listener),storeListeners.forEach((l=>l("sub"))),()=>{listeners.delete(listener),(atom=>{const mounted=mountedMap.get(atom);mounted&&canUnmountAtom(atom,mounted)&&unmountAtom(atom)})(atom),storeListeners.forEach((l=>l("unsub")))}};return{get:readAtom,set:writeAtom,sub:subscribeAtom,dev_subscribe_state:l=>(console.warn("[DEPRECATED] dev_subscribe_state is deprecated and will be removed in the next minor version. use dev_subscribe_store instead."),stateListeners.add(l),()=>{stateListeners.delete(l)}),dev_subscribe_store:l=>(storeListeners.add(l),()=>{storeListeners.delete(l)}),dev_get_mounted_atoms:()=>mountedAtoms.values(),dev_get_atom_state:a=>atomStateMap.get(a),dev_get_mounted:a=>mountedMap.get(a),dev_restore_atoms:values=>{for(const[atom,value]of values)hasInitialValue(atom)&&(setAtomValue(atom,value),recomputeDependents(atom));flushPending()}}};let defaultStore;const getDefaultStore=()=>(defaultStore||(defaultStore=createStore()),defaultStore)},"../../../node_modules/.pnpm/jotai@2.0.3_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{KU:function(){return atomFamily}});Symbol();function atomFamily(initializeAtom,areEqual){let shouldRemove=null;const atoms=new Map,createAtom=param=>{let item;if(void 0===areEqual)item=atoms.get(param);else for(const[key,value]of atoms)if(areEqual(key,param)){item=value;break}if(void 0!==item){if(!(null==shouldRemove?void 0:shouldRemove(item[1],param)))return item[0];createAtom.remove(param)}const newAtom=initializeAtom(param);return atoms.set(param,[newAtom,Date.now()]),newAtom};return createAtom.remove=param=>{if(void 0===areEqual)atoms.delete(param);else for(const[key]of atoms)if(areEqual(key,param)){atoms.delete(key);break}},createAtom.setShouldRemove=fn=>{if(shouldRemove=fn,shouldRemove)for(const[key,value]of atoms)shouldRemove(value[1],key)&&atoms.delete(key)},createAtom}const NO_STORAGE_VALUE=Symbol();(function createJSONStorage(getStringStorage){let lastStr,lastValue;const storage={getItem:key=>{var _a,_b;const parse=str2=>{if(lastStr!==(str2=str2||"")){try{lastValue=JSON.parse(str2)}catch{return NO_STORAGE_VALUE}lastStr=str2}return lastValue},str=null!=(_b=null==(_a=getStringStorage())?void 0:_a.getItem(key))?_b:null;return str instanceof Promise?str.then(parse):parse(str)},setItem:(key,newValue)=>{var _a;return null==(_a=getStringStorage())?void 0:_a.setItem(key,JSON.stringify(newValue))},removeItem:key=>{var _a;return null==(_a=getStringStorage())?void 0:_a.removeItem(key)}};return"undefined"!=typeof window&&"function"==typeof window.addEventListener&&(storage.subscribe=(key,callback)=>{const storageEventCallback=e=>{e.key===key&&e.newValue&&callback(JSON.parse(e.newValue))};return window.addEventListener("storage",storageEventCallback),()=>{window.removeEventListener("storage",storageEventCallback)}}),storage})((()=>"undefined"!=typeof window?window.localStorage:void 0))},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseXor.js":function(module,__unused_webpack_exports,__webpack_require__){var baseDifference=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"),baseFlatten=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"),baseUniq=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js");module.exports=function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2)return length?baseUniq(arrays[0]):[];for(var index=-1,result=Array(length);++index<length;)for(var array=arrays[index],othIndex=-1;++othIndex<length;)othIndex!=index&&(result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator));return baseUniq(baseFlatten(result,1),iteratee,comparator)}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js":function(module,__unused_webpack_exports,__webpack_require__){var baseAssignValue=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"),baseForOwn=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"),baseIteratee=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js");module.exports=function mapValues(object,iteratee){var result={};return iteratee=baseIteratee(iteratee,3),baseForOwn(object,(function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object))})),result}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/xor.js":function(module,__unused_webpack_exports,__webpack_require__){var arrayFilter=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"),baseRest=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"),baseXor=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseXor.js"),isArrayLikeObject=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"),xor=baseRest((function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject))}));module.exports=xor}}]);